---
source: compiler-core/src/nix/tests/basic.rs
expression: "\npub type Amogus {\n  AmogusA\n  AmogusB(a: Int, b: Int)\n  AmogusC(Int, Float)\n}\n\npub const sumongus: Int = 5\n\npub fn sus(x: Int) -> Int {\n    5 + 5\n}\n\nfn go(x, foo, boolthing, bmong) {\n  let a = 1\n  foo\n  let a = 2\n  let z = [fn(y: Int) { y }, foo(a, a, 50), fn(x: Int) { x }]\n  let d = {\n    \"aaa\"\n  }\n  let dd = {\n    let amogus = 5.5e5\n  }\n  let intdiv = 5 / 5\n  let floatdiv = 5.0 /. 5.0\n  let remm = 5 % 5\n  let g = 0.5\n  let b = a\n  foo(a, a, 50)\n  let c = {\n    let a = a\n    [a]\n  }\n  foo\n  let www = a == 5\n  let wwww = {a + a} == {10 - 5 * 5}\n  let first_list = [1 < 4, 3 >= 5]\n  let list_thing = [www, ..first_list]\n  let pipes =\n    a\n    |> foo(_, a, 50)\n    |> fn(x) { x }\n  let pipes2 = a |> fn(i: Int) { i }\n  panic as \"amongus\"\n  todo as \"amongus\"\n  panic\n  todo\n  // let mongus: Amogus = bmong\n  // let mongus = bmong.a\n  // let mongus = Amogus(..bmong, a: 6)\n  let y = -500 + 10 - {-a} - {-5}\n  let yy = [ -a, -5, -y ]\n  let f = -5.5 -. 5.2e-5\n  let f = 5.5 -. 5.2e5\n  // TODO: fix string escaping\n  let ss = \"a\" <> \"b\" <> \"c d\"\n  let ff = [ -5.2e-5, -5.5 ]\n  let z = !boolthing\n  let tupdatup = #(1, 2, \"a\", -5.5, #(1, 2, 3))\n  let tata = tupdatup.1 + tupdatup.0 + 20\n  let mabool = True\n  let mnotbool = False\n  let amagus_a = AmogusA\n  let amagus_b = AmogusB(10, b: 15)\n  let amagus_c = AmogusC(10, 5.5)\n  let simplefunc = fn() { 5 }\n  let gg = simplefunc() + 10\n  let less_simple_func = fn(x) { fn() { x } }\n  let gg = less_simple_func(5)() + 10\n  let mnull = Nil\n  let sus = \"hey! I'm still sus :(\"\n  // make sure arguments are counted in initial state\n  let x = tata\n  x\n}\n\nfn mongus(a, b, c) {\n  let x = fn() { 5 + 5 }\n  let y = x()\n  #(1, 2, 3, fn(x: Int) { x + 1 }, { 5 6 10 {10 + 5} })\n}\n"
---
let
  inherit
    (builtins.import ./../gleam.nix)
    toList
    remainderInt
    divideFloat
    divideInt;
  listPrepend = (builtins.import ./../gleam.nix).prepend;
  
  AmogusA = { __gleam_tag' = "AmogusA"; };
  
  AmogusB = a: b: { __gleam_tag' = "AmogusB"; inherit a b; };
  
  AmogusC = x0: x1: { __gleam_tag' = "AmogusC"; _0 = x0; _1 = x1; };
  
  sus = x: 5 + 5;
  
  go =
    x: foo: boolthing: bmong:
      let
        a = 1;
        _''0 = foo;
        a'1 = 2;
        z = toList [ (y: y) (foo a'1 a'1 50) (x: x) ];
        d = "aaa";
        dd = 5.5e5;
        intdiv = divideInt 5 5;
        floatdiv = divideFloat 5.0 5.0;
        remm = remainderInt 5 5;
        g = 0.5;
        b = a'1;
        _''1 = foo a'1 a'1 50;
        c = let a'2 = a'1; in toList [ a'2 ];
        _''2 = foo;
        www = a'1 == 5;
        wwww = (a'1 + a'1) == (10 - (5 * 5));
        first_list = toList [ (1 < 4) (3 >= 5) ];
        list_thing = listPrepend www first_list;
        pipes =
          let
            _pipe = a'1;
            _pipe'1 = (_capture: foo _capture a'1 50) _pipe;
          in (x: x) _pipe'1;
        pipes2 = let _pipe = a'1; in (i: i) _pipe;
        _''3 = builtins.throw "amongus";
        _''4 = builtins.throw "amongus";
        _''5 = builtins.throw "panic expression evaluated";
        _''6 = builtins.throw "This has not yet been implemented";
        y = (((-500) + 10) - (-a'1)) - (-5);
        yy = toList [ (-a'1) (-5) (-y) ];
        f = (-5.5) - 5.2e-5;
        f'1 = 5.5 - 5.2e5;
        ss = ("a" + "b") + "c d";
        ff = toList [ (-5.2e-5) (-5.5) ];
        z'1 = !boolthing;
        tupdatup =
          {
            _0 = 1;
            _1 = 2;
            _2 = "a";
            _3 = -5.5;
            _4 = { _0 = 1; _1 = 2; _2 = 3; };
          };
        tata = (tupdatup._1 + tupdatup._0) + 20;
        mabool = true;
        mnotbool = false;
        amagus_a = AmogusA;
        amagus_b = AmogusB 10 15;
        amagus_c = AmogusC 10 5.5;
        simplefunc = 5;
        gg = simplefunc + 10;
        less_simple_func = x: x;
        gg'1 = (less_simple_func 5) + 10;
        mnull = null;
        sus'1 = "hey! I'm still sus :(";
        x'1 = tata;
      in x'1;
  
  mongus =
    a: b: c:
      let
        x = 5 + 5;
        y = x;
      in
        {
          _0 = 1;
          _1 = 2;
          _2 = 3;
          _3 = x: x + 1;
          _4 = let _''0 = 5; _''1 = 6; _''2 = 10; in 10 + 5;
        };
  
  sumongus = 5;
in { inherit AmogusA AmogusB AmogusC sus sumongus; }
